// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"sort"
	"strings"
	"text/template"

	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
)

type Event struct {
	Name   string
	Code   string
	Fields []Field
}

type Field struct {
	Name string
	Type string
	Kind string
}

func TypeName(v ast.Node) string {
	switch v := v.(type) {
	case *ast.Ident:
		return v.Name
	case *ast.ArrayType:
		return "[]" + TypeName(v.Elt)
	}
	panic(fmt.Sprintf("unhandled type: %T", v))
}

func TypeToKind(v string) string {
	switch v {
	case "[]byte":
		return "Bytes"
	}
	return strings.Title(v)
}

func NewEvent(name, doc string, typ *ast.StructType) *Event {
	event := &Event{Name: name}
	for _, line := range strings.Split(doc, "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "event:") {
			code := strings.TrimPrefix(line, "event:")
			code = strings.TrimSpace(code)
			event.Code = code
			break
		}
	}
	if event.Code == "" {
		return nil
	}

	for _, field := range typ.Fields.List {
		for _, name := range field.Names {
			typ := TypeName(field.Type)
			event.Fields = append(event.Fields, Field{
				Name: name.Name,
				Type: typ,
				Kind: TypeToKind(typ),
			})
		}
	}

	return event
}

var Code = template.Must(template.New("").Parse(`
// GENERATED BY events_encoding_gen.go
// DO NOT MODIFY MANUALLY
package trace

func NewEventByCode(code byte) Event {
	switch code {
	{{ range $event := .Events }}case {{$event.Code}}: return &{{$event.Name}}{}; {{ end }}
	}
	panic("unknown code")
}

{{ range $event := .Events }}
// {{$event.Name}} {{$event.Code}}
func (ev *{{$event.Name}}) Code() byte { return {{$event.Code}} }
func (ev *{{$event.Name}}) Decode(dec *Decoder) {
	{{ range $field := $event.Fields }} ev.{{$field.Name}} = dec.read{{$field.Kind}}(); {{ end }}
}
func (ev *{{$event.Name}}) Encode(enc *Encoder) {
	{{ range $field := $event.Fields }} enc.write{{$field.Kind}}(ev.{{$field.Name}}); {{ end }}
}
{{ end }}
`))

type ByCode []*Event

func (a ByCode) Len() int           { return len(a) }
func (a ByCode) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByCode) Less(i, j int) bool { return a[i].Code < a[j].Code }

func main() {
	fset := token.NewFileSet() // positions are relative to fset

	// Parse the file containing this very example
	// but stop after processing the imports.
	f, err := parser.ParseFile(fset, "events.go", nil, parser.ParseComments)
	check(err)

	events := []*Event{}
	for name, obj := range f.Scope.Objects {
		if obj.Kind != ast.Typ {
			continue
		}

		typ, ok := obj.Decl.(*ast.TypeSpec).Type.(*ast.StructType)
		if !ok {
			continue
		}

		doc := obj.Decl.(*ast.TypeSpec).Doc.Text()

		if ev := NewEvent(name, doc, typ); ev != nil {
			events = append(events, ev)
		}
	}

	sort.Sort(ByCode(events))

	var buf bytes.Buffer
	check(Code.Execute(&buf, map[string]interface{}{
		"Events": events,
	}))

	bytes := buf.Bytes()
	fmted, err := format.Source(bytes)
	check(err)

	check(ioutil.WriteFile("events_encoding.go", fmted, 0777))
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
